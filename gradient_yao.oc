
#include "yao.h"
#include "wrapper.h"

#include <obliv.oh>
#include <stdio.h>
#include <sys/time.h>
#include <math.h>

obliv int generate_binomial_noise(configuration_t* config, double sd) {
  int prec = GetQuantizeBitsPrecision(config);

  // a binomial distribution from an unbiased coin has SD =
  // .25*sqrt(n), where n is the number of trials.  Also, for a random
  // variable X with sd(x) = s, sd(X/a) = s/a.
  int bits_needed = ceil((1 << 2*prec) * sd * sd);
  int bits_generated = 0;

  /* printf("Rand bits: %d\n", bits_needed); */

  obliv int result = 0;

  // we can generate the randomness in groups of 64 using long longs
  for (; bits_needed > 0; bits_needed -= 64) {
    // rand max is at least 2^15
    unsigned long long r1 = rand(), r2 = rand(), r3 = rand(), r4 = rand(), r5 = rand();
    unsigned long long r = r1 ^ (r2 << 15) ^ (r3 << 30) ^ (r4 << 45) ^ (r5 << 60);

    obliv unsigned long long or1 = feedOblivLLong(r, 1);
    obliv unsigned long long or2 = feedOblivLLong(r, 2);

    obliv unsigned long long rand_bits = or1 ^ or2;

    // now get the hamming weight
    rand_bits = ((rand_bits & 0xAAAAAAAAAAAAAAAALL) >> 1) + (rand_bits & 0x5555555555555555LL);
    rand_bits = ((rand_bits & 0xCCCCCCCCCCCCCCCCLL) >> 2) + (rand_bits & 0x3333333333333333LL);
    rand_bits = ((rand_bits & 0xF0F0F0F0F0F0F0F0LL) >> 4) + (rand_bits & 0x0F0F0F0F0F0F0F0FLL);
    rand_bits = ((rand_bits & 0xFF00FF00FF00FF00LL) >> 8) + (rand_bits & 0x00FF00FF00FF00FFLL);
    rand_bits = ((rand_bits & 0xFFFF0000FFFF0000LL) >> 16) + (rand_bits & 0x0000FFFF0000FFFFLL);
    rand_bits = ((rand_bits & 0xFFFFFFFF00000000LL) >> 32) + (rand_bits & 0x00000000FFFFFFFFLL);

    // and add that to the result
    result += rand_bits;
    bits_generated += 64;
  }

  // we want to center the randomness around 0
  result -= (bits_generated / 2);


  return result;
}

obliv int* generate_gradient_noise(configuration_t* config, int d, double std_dev) {
  obliv int* noise = calloc(d+1, sizeof(obliv int));
  for (int i = 0; i < d+1; i++) {
    /* fprintf(stderr, "Noise: %d\n", i); */
    noise[i] = generate_binomial_noise(config, std_dev);
  }

  return noise;
}

void do_gradient_train(void* args) {
  gradientProtocolIO* io = args;
  configuration_t* config = io->config;
  party_t* party = io->party;
  model_t* model = io->model;

  struct timeval t1, t2;
  gettimeofday(&t1, NULL);
  
  int steps = GetIterationCount(config);
  int num_features = GetDataFeatureCount(party);

  double noise_sd = GetNoiseStdDev(config);

  for (int i = 0; i < steps; i++) {
    fprintf(stderr, "starting step: %d\n", i);
    int* gradient = ComputeGradient(party, model);

    obliv int* grad1 = calloc(num_features+1, sizeof(obliv int));
    obliv int* grad2 = calloc(num_features+1, sizeof(obliv int));
    obliv int* grad_sum = calloc(num_features+1, sizeof(obliv int));

    feedOblivIntArray(grad1, gradient, num_features+1, 1);
    feedOblivIntArray(grad2, gradient, num_features+1, 2);

    obliv int* noise = generate_gradient_noise(config, num_features, noise_sd);

    for (int j = 0; j < num_features+1; j++) {
      grad_sum[j] = grad1[j] + grad2[j] + noise[j];
    }

    int* final_gradient = calloc(num_features+1, sizeof(int));
    int noise0;
    for (int j = 0; j < num_features+1; j++) {
      revealOblivInt(final_gradient + j, grad_sum[j], 0);
      /* revealOblivInt(&noise0, noise[0], 0); */
    }

    UpdateModel(model, i, final_gradient);
    free(grad1);
    free(grad2);
    free(gradient);
    free(final_gradient);
    free(noise);
  }

  gettimeofday(&t2, NULL);
  printf("Gate Count: %d\n", yaoGateCount());
  long elapsed;
  elapsed = (t2.tv_sec - t1.tv_sec) * 1000;
  elapsed += (t2.tv_usec - t1.tv_usec) / 1000;
  printf("Elapsed Time: %dms\n", elapsed);
}
